# Telemetry configuration
telemetry:
  # URL configuration - api key also goes here for updating monitors
    secretName: "cronitor-secret"

# OpenAI-compatible endpoints to monitor
# Add your endpoints here or use values overrides
# Valid model types are 'chat' and 'embedding'. 
# Chat requests receive a single message containing 'test', with 1 output token requested. 
# Embedding models receive a single message containing 'test'.
endpoints: []
  # Example:
  # - name: "onwards-service"
  #   url: "http://onwards-service"
  #   models: 
  #       # OpenAI Embedding Example
  #     - name: "embed"
  #       type: "openai-embedding"
  #       monitor: "my-embedding-model"  # Optional: cronitor monitor name
  #     
  #       # OpenAI Chat Completion example
  #     - name: "generate"
  #       type: "openai-chat-completion"
  #       monitor: "my-chat-model"  # Optional: cronitor monitor name
  #       monitorGroup: "group1" # Optional: group for monitor to go in
  #       consecutiveFailures: 1 # Optional: how many failed pings are needed to trigger an alert.
  #       consecutiveMissing: 1 # Optional: how many missing pings are needed to trigger an alert.
  #       minFreqRequiredMins: 60
  #     
  #       # Newman Example
  #     - name: "newman"
  #       type: "newman"
  #       collectionName: "your-collection.json" # Optional: Name of the Newman collection file you want to use from the k8s ConfigMap created below
  #       environmentName: "environment.json" # Optional: Name of the Newman environment file you want to use from the k8s Secret created below
  #       delayMilliseconds: 1000 # Optional: Delay each request by N milliseconds to avoid rate limits
  #       monitor: "my-api"  # Optional: cronitor monitor name
  #       monitorGroup: "group1" # Optional: group for monitor to go in
  #       consecutiveFailures: 1 # Optional: how many failed pings are needed to trigger an alert.
  #       consecutiveMissing: 1 # Optional: how many missing pings are needed to trigger an alert.

# minFreqRequiredMins catches inactive alerts - if an alert starts but never completes, it'll be marked as inactive by
# Cronitor. To force this into raising an alert, we require a successful ping once per any minFreqRequiredMins period.

# CronJob configuration
cronJob:
  # Schedule for all monitoring jobs (every 5 minutes)
  schedule: "*/5 * * * *"

  # Container image
  image:
    repository: ghcr.io/doublewordai/model-monitor/ai-vitals
    tag: ""
    pullPolicy: "IfNotPresent"

  # Job settings: if this is not never
  restartPolicy: "Never"

  # Pod retry behavior when failures occur
  # backoffLimit: Number of retries before considering a Job as failed
  # - Default (if unset): 6 retries with exponential backoff (10s, 20s, 40s, etc.)
  # - For monitoring jobs, 0 is recommended since the CronJob will retry on the next schedule
  # backoffLimit: 0

  # activeDeadlineSeconds: Maximum time in seconds for the Job to run before being terminated
  # - Prevents jobs from running indefinitely
  # - Should be less than your cron schedule interval to avoid overlapping jobs
  # - Example: For a 5-minute schedule (300s), set to 240s to ensure completion before next run
  # - Uncomment and adjust based on your needs:
  # activeDeadlineSeconds: 240

  # Resource limits/requests
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 50m
    #   memory: 64Mi

  
# Kubernetes metadata
nameOverride: ""
fullnameOverride: ""

# Newman configuration
newman:
  configMap:
    enabled: false
    # Files to include in the ConfigMap (populated from local files)
    # Use: --set-file newman.configMap.files.collection\\.json=./path/to/your/collection.json
    # Or add files directly in values:
    files: {}
      # collection.json: |
      #   {
      #     "info": {
      #       "name": "Your Collection"
      #     }
      #   }

  secret:
    enabled: false
    # Files to include in the Secret (populated from local files)
    # Use: --set-file newman.secret.files.environment\\.json=./path/to/your/environment.json
    # Or add files directly in values:
    files: {}
      # environment.json: |
      #   {
      #     "id": "environment-id",
      #     "name": "Environment Name",
      #     "values": [
      #       {
      #         "key": "api_key",
      #         "value": "secret-api-key",
      #         "type": "secret"
      #       }
      #     ]
      #   }

# Common labels
commonLabels:
  app.kubernetes.io/name: model-monitor
  app.kubernetes.io/instance: model-monitor
